-- Security Camera System by sherikyt
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

local config = {
    maxCameras = 5,
    cameraFOV = 70,
    panSpeed = 50,
    zoomSpeed = 5
}

local state = {
    cameras = {},
    currentCamera = nil,
    cameraIndex = 0,
    isMonitoring = false,
    zoomLevel = 1
}

-- Simple GUI without complex UI
local gui = Instance.new("ScreenGui")
gui.Parent = player:WaitForChild("PlayerGui")

-- Status label
local status = Instance.new("TextLabel")
status.Size = UDim2.new(0, 200, 0, 50)
status.Position = UDim2.new(0, 10, 0, 10)
status.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
status.BackgroundTransparency = 0.3
status.Text = "Cameras: 0/5\nPress P to place\nM to monitor"
status.TextColor3 = Color3.fromRGB(255, 255, 255)
status.Font = Enum.Font.Gotham
status.TextSize = 12
status.TextWrapped = true
status.Parent = gui

Instance.new("UICorner", status).CornerRadius = UDim.new(0, 8)

-- Monitor overlay (hidden)
local monitorOverlay = Instance.new("Frame")
monitorOverlay.Size = UDim2.new(1, 0, 1, 0)
monitorOverlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
monitorOverlay.BackgroundTransparency = 0.95
monitorOverlay.Visible = false
monitorOverlay.Parent = gui

local cameraInfo = Instance.new("TextLabel")
cameraInfo.Size = UDim2.new(0, 300, 0, 60)
cameraInfo.Position = UDim2.new(1, -310, 0, 10)
cameraInfo.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
cameraInfo.BackgroundTransparency = 0.7
cameraInfo.Text = "Camera 0\nWASD: Move | QE: Zoom\n←→: Switch | R: Reset"
cameraInfo.TextColor3 = Color3.fromRGB(255, 255, 255)
cameraInfo.Font = Enum.Font.Gotham
cameraInfo.TextSize = 14
cameraInfo.TextWrapped = true
cameraInfo.Parent = monitorOverlay

Instance.new("UICorner", cameraInfo).CornerRadius = UDim.new(0, 8)

-- SUPER SIMPLE Camera creation - Just store position
local function createCamera(position, index)
    -- Create a simple marker part
    local marker = Instance.new("Part")
    marker.Name = "CameraMarker_" .. index
    marker.Size = Vector3.new(1, 1, 1)
    marker.Position = position
    marker.Anchored = true
    marker.CanCollide = false
    marker.Transparency = 0.7
    marker.Color = Color3.fromRGB(0, 150, 255)
    marker.Parent = Workspace
    
    -- Store camera data
    local cameraData = {
        position = position,
        marker = marker,
        index = index,
        rotation = Vector2.new(0, 0),
        fov = config.cameraFOV
    }
    
    return cameraData
end

local function updateStatus()
    local count = #state.cameras
    if state.isMonitoring then
        status.Text = string.format("Monitoring\nCamera %d/%d\n←→ to switch", 
            state.cameraIndex, count)
    else
        status.Text = string.format("Cameras: %d/%d\nP: Place camera\nM: Monitor mode", 
            count, config.maxCameras)
    end
end

local function placeCamera()
    if #state.cameras >= config.maxCameras then
        print("Max cameras reached")
        return
    end
    
    local character = player.Character
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    -- Place camera 15 units above and 5 units in front
    local offset = hrp.CFrame.LookVector * 5 + Vector3.new(0, 15, 0)
    local position = hrp.Position + offset
    
    local index = #state.cameras + 1
    local cameraData = createCamera(position, index)
    
    table.insert(state.cameras, cameraData)
    print("Camera placed at:", position)
    updateStatus()
end

local function clearAllCameras()
    for _, cam in ipairs(state.cameras) do
        if cam.marker then
            cam.marker:Destroy()
        end
    end
    state.cameras = {}
    updateStatus()
end

local function switchCamera(direction)
    if #state.cameras == 0 then return end
    
    if direction == "next" then
        state.cameraIndex = state.cameraIndex + 1
        if state.cameraIndex > #state.cameras then
            state.cameraIndex = 1
        end
    elseif direction == "prev" then
        state.cameraIndex = state.cameraIndex - 1
        if state.cameraIndex < 1 then
            state.cameraIndex = #state.cameras
        end
    end
    
    state.currentCamera = state.cameras[state.cameraIndex]
    
    if state.currentCamera then
        cameraInfo.Text = string.format("Camera %d/%d\nWASD: Move | QE: Zoom\n←→: Switch | R: Reset",
            state.cameraIndex, #state.cameras)
        
        -- Update marker colors
        for i, cam in ipairs(state.cameras) do
            if cam.marker then
                cam.marker.Color = (i == state.cameraIndex) and 
                    Color3.fromRGB(255, 50, 50) or Color3.fromRGB(0, 150, 255)
            end
        end
    end
    
    updateStatus()
end

local function startMonitoring()
    if #state.cameras == 0 then
        print("No cameras to monitor")
        return
    end
    
    state.isMonitoring = true
    state.cameraIndex = 1
    state.currentCamera = state.cameras[1]
    
    -- Switch camera type
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
    monitorOverlay.Visible = true
    
    -- Update markers
    for i, cam in ipairs(state.cameras) do
        if cam.marker then
            cam.marker.Color = (i == 1) and 
                Color3.fromRGB(255, 50, 50) or Color3.fromRGB(0, 150, 255)
        end
    end
    
    cameraInfo.Text = string.format("Camera 1/%d\nWASD: Move | QE: Zoom\n←→: Switch | R: Reset",
        #state.cameras)
    
    updateStatus()
end

local function stopMonitoring()
    state.isMonitoring = false
    
    -- Return to normal camera
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    monitorOverlay.Visible = false
    
    -- Reset marker colors
    for _, cam in ipairs(state.cameras) do
        if cam.marker then
            cam.marker.Color = Color3.fromRGB(0, 150, 255)
        end
    end
    
    updateStatus()
end

local function toggleMonitoring()
    if state.isMonitoring then
        stopMonitoring()
    else
        startMonitoring()
    end
end

-- Camera control loop
local monitorConnection
local function setupMonitorControls()
    if monitorConnection then
        monitorConnection:Disconnect()
    end
    
    monitorConnection = RunService.RenderStepped:Connect(function(delta)
        if not state.isMonitoring or not state.currentCamera then return end
        
        local camera = Workspace.CurrentCamera
        local camData = state.currentCamera
        
        -- Calculate camera position with offset based on rotation
        local basePos = camData.position
        local yaw = camData.rotation.X
        local pitch = camData.rotation.Y
        
        -- Calculate offset from rotation
        local distance = 15 * state.zoomLevel
        local offset = Vector3.new(
            math.sin(yaw) * math.cos(pitch) * distance,
            math.sin(pitch) * distance,
            math.cos(yaw) * math.cos(pitch) * distance
        )
        
        local cameraPos = basePos + offset
        
        -- Set camera
        camera.CFrame = CFrame.new(cameraPos, basePos)
        camera.FieldOfView = camData.fov / state.zoomLevel
        
        -- Handle controls
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            camData.rotation = Vector2.new(
                camData.rotation.X - delta * config.panSpeed,
                camData.rotation.Y
            )
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            camData.rotation = Vector2.new(
                camData.rotation.X + delta * config.panSpeed,
                camData.rotation.Y
            )
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            camData.rotation = Vector2.new(
                camData.rotation.X,
                math.max(camData.rotation.Y - delta * config.panSpeed, -1.5)
            )
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            camData.rotation = Vector2.new(
                camData.rotation.X,
                math.min(camData.rotation.Y + delta * config.panSpeed, 1.5)
            )
        end
        
        -- Zoom
        if UserInputService:IsKeyDown(Enum.KeyCode.Q) then
            state.zoomLevel = math.min(state.zoomLevel + delta * config.zoomSpeed, 5)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.E) then
            state.zoomLevel = math.max(state.zoomLevel - delta * config.zoomSpeed, 0.5)
        end
    end)
end

-- Keyboard controls
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    
    if input.KeyCode == Enum.KeyCode.P then
        placeCamera()
        
    elseif input.KeyCode == Enum.KeyCode.M then
        toggleMonitoring()
        
    elseif input.KeyCode == Enum.KeyCode.C then
        clearAllCameras()
        
    elseif state.isMonitoring then
        if input.KeyCode == Enum.KeyCode.Right then
            switchCamera("next")
        elseif input.KeyCode == Enum.KeyCode.Left then
            switchCamera("prev")
        elseif input.KeyCode == Enum.KeyCode.R then
            -- Reset current camera
            if state.currentCamera then
                state.currentCamera.rotation = Vector2.new(0, 0)
                state.zoomLevel = 1
            end
        end
    end
end)

-- Initialize
setupMonitorControls()
updateStatus()

print("Camera System by sherikyt loaded")
print("Controls:")
print("P - Place camera (max 5)")
print("M - Toggle monitor mode")
print("C - Clear all cameras")
print("In monitor: WASD to move, QE to zoom, ←→ to switch")
