-- Mobile Fly & Mark System by sherikyt
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local config = {
    maxMarkers = 5,
    flySpeed = 25,
    cameraFOV = 70
}

local state = {
    markers = {},
    currentMarkerIndex = 0,
    isViewing = false,
    isFlying = false,
    flyPosition = Vector3.new(0, 0, 0),
    flyAngle = Vector2.new(0, 0), -- X = yaw, Y = pitch
    viewAngle = Vector2.new(0, 0),
    zoomLevel = 1
}

-- Simple GUI
local gui = Instance.new("ScreenGui")
gui.Name = "FlyMarkSystem"
gui.Parent = playerGui

-- Status display
local status = Instance.new("TextLabel")
status.Size = UDim2.new(0, 250, 0, 80)
status.Position = UDim2.new(0, 10, 0, 10)
status.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
status.BackgroundTransparency = 0.3
status.Text = "Fly & Mark System\nby sherikyt\nMarkers: 0/5"
status.TextColor3 = Color3.fromRGB(255, 255, 255)
status.Font = Enum.Font.Gotham
status.TextSize = 14
status.TextWrapped = true
status.Parent = gui

local statusCorner = Instance.new("UICorner")
statusCorner.CornerRadius = UDim.new(0, 10)
statusCorner.Parent = status

-- Main buttons
local function createSimpleButton(name, text, position, color)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Size = UDim2.new(0, 120, 0, 50)
    button.Position = position
    button.BackgroundColor3 = color
    button.Text = text
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.GothamBold
    button.TextSize = 14
    button.TextWrapped = true
    button.Parent = gui
    
    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 10)
    btnCorner.Parent = button
    
    return button
end

local flyBtn = createSimpleButton("FlyBtn", "FREE CAMERA", UDim2.new(0, 10, 0, 100), Color3.fromRGB(0, 150, 255))
local markBtn = createSimpleButton("MarkBtn", "PLACE MARK", UDim2.new(0, 140, 0, 100), Color3.fromRGB(255, 180, 0))
local viewBtn = createSimpleButton("ViewBtn", "VIEW MARKS", UDim2.new(0, 10, 0, 160), Color3.fromRGB(150, 0, 255))
local clearBtn = createSimpleButton("ClearBtn", "CLEAR ALL", UDim2.new(0, 140, 0, 160), Color3.fromRGB(255, 50, 50))
local exitBtn = createSimpleButton("ExitBtn", "EXIT", UDim2.new(0, 10, 0, 220), Color3.fromRGB(100, 100, 100))

-- Hide exit button initially
exitBtn.Visible = false

-- Fly controls (shown when flying)
local flyControls = Instance.new("Frame")
flyControls.Size = UDim2.new(1, 0, 0, 150)
flyControls.Position = UDim2.new(0, 0, 1, -150)
flyControls.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
flyControls.BackgroundTransparency = 0.7
flyControls.Visible = false
flyControls.Parent = gui

-- Fly control buttons
local function createFlyButton(text, position)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0, 70, 0, 70)
    btn.Position = position
    btn.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
    btn.Text = text
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 20
    btn.Parent = flyControls
    
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 10)
    
    return btn
end

-- Movement buttons
local flyUp = createFlyButton("⬆", UDim2.new(0.5, -35, 0, 10))
local flyDown = createFlyButton("⬇", UDim2.new(0.5, -35, 1, -80))
local flyLeft = createFlyButton("⬅", UDim2.new(0.2, -35, 0.5, -35))
local flyRight = createFlyButton("➡", UDim2.new(0.8, -35, 0.5, -35))
local flyForward = createFlyButton("F", UDim2.new(0.35, -35, 0.3, -35))
local flyBack = createFlyButton("B", UDim2.new(0.65, -35, 0.3, -35))

-- Camera rotation buttons
local lookLeft = createFlyButton("◀", UDim2.new(0.05, -35, 0.5, -35))
local lookRight = createFlyButton("▶", UDim2.new(0.95, -35, 0.5, -35))
local lookUp = createFlyButton("▲", UDim2.new(0.5, -35, 0.1, -35))
local lookDown = createFlyButton("▼", UDim2.new(0.5, -35, 0.9, -35))

-- Teleport button (shown when flying)
local teleportBtn = createSimpleButton("TeleportBtn", "TELEPORT", UDim2.new(0, 270, 0, 220), Color3.fromRGB(0, 200, 100))
teleportBtn.Visible = false
teleportBtn.Parent = gui

-- View controls (shown when viewing marks)
local viewControls = Instance.new("Frame")
viewControls.Size = UDim2.new(1, 0, 0, 150)
viewControls.Position = UDim2.new(0, 0, 1, -150)
viewControls.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
viewControls.BackgroundTransparency = 0.7
viewControls.Visible = false
viewControls.Parent = gui

-- View control buttons
local viewPrev = createSimpleButton("ViewPrev", "⬅ PREV", UDim2.new(0.1, 0, 0, 20), Color3.fromRGB(80, 80, 100))
viewPrev.Parent = viewControls
viewPrev.Size = UDim2.new(0, 100, 0, 60)

local viewNext = createSimpleButton("ViewNext", "NEXT ➡", UDim2.new(0.9, -100, 0, 20), Color3.fromRGB(80, 80, 100))
viewNext.Parent = viewControls
viewNext.Size = UDim2.new(0, 100, 0, 60)

local viewUp = createSimpleButton("ViewUp", "UP", UDim2.new(0.35, -50, 0, 20), Color3.fromRGB(80, 80, 100))
viewUp.Parent = viewControls
viewUp.Size = UDim2.new(0, 100, 0, 60)

local viewDown = createSimpleButton("ViewDown", "DOWN", UDim2.new(0.65, -50, 0, 20), Color3.fromRGB(80, 80, 100))
viewDown.Parent = viewControls
viewDown.Size = UDim2.new(0, 100, 0, 60)

-- Marker functions
local function createMarker(position, index)
    local marker = Instance.new("Part")
    marker.Name = "Mark_" .. index
    marker.Size = Vector3.new(2, 2, 2)
    marker.Position = position
    marker.Anchored = true
    marker.CanCollide = false
    marker.Transparency = 0.5
    marker.Color = Color3.fromRGB(0, 150, 255)
    marker.Parent = Workspace
    
    -- Add light
    local light = Instance.new("PointLight")
    light.Color = Color3.fromRGB(0, 150, 255)
    light.Brightness = 2
    light.Range = 10
    light.Parent = marker
    
    return marker
end

local function updateStatus()
    local count = #state.markers
    if state.isFlying then
        status.Text = string.format("FLYING MODE\nMarkers: %d/5\nRotate camera with ◀ ▶ ▲ ▼", count)
    elseif state.isViewing then
        status.Text = string.format("VIEWING MODE\nMarker: %d/%d\nMove camera with buttons", 
            state.currentMarkerIndex, count)
    else
        status.Text = string.format("Fly & Mark System\nby sherikyt\nMarkers: %d/5", count)
    end
end

local function placeMarker()
    if #state.markers >= config.maxMarkers then
        status.Text = "MAX 5 MARKERS REACHED"
        return
    end
    
    local camera = Workspace.CurrentCamera
    local position = camera.CFrame.Position
    local index = #state.markers + 1
    
    createMarker(position, index)
    
    table.insert(state.markers, {
        position = position,
        index = index
    })
    
    updateStatus()
end

local function clearAllMarkers()
    for _, part in pairs(Workspace:GetChildren()) do
        if string.find(part.Name, "Mark_") then
            part:Destroy()
        end
    end
    state.markers = {}
    state.currentMarkerIndex = 0
    updateStatus()
end

-- Flying system
local function startFlying()
    if state.isFlying then return end
    
    state.isFlying = true
    local camera = Workspace.CurrentCamera
    state.flyPosition = camera.CFrame.Position
    
    -- Get initial camera angles
    local lookVector = camera.CFrame.LookVector
    state.flyAngle = Vector2.new(
        math.atan2(-lookVector.X, -lookVector.Z), -- Yaw
        math.asin(lookVector.Y) -- Pitch
    )
    
    -- Switch camera
    camera.CameraType = Enum.CameraType.Scriptable
    
    -- Show/hide UI
    flyControls.Visible = true
    exitBtn.Visible = true
    teleportBtn.Visible = true
    flyBtn.Visible = false
    markBtn.Visible = false
    viewBtn.Visible = false
    clearBtn.Visible = false
    
    updateStatus()
end

local function stopFlying()
    if not state.isFlying then return end
    
    state.isFlying = false
    
    -- Return camera
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    
    -- Show/hide UI
    flyControls.Visible = false
    exitBtn.Visible = false
    teleportBtn.Visible = false
    flyBtn.Visible = true
    markBtn.Visible = true
    viewBtn.Visible = true
    clearBtn.Visible = true
    
    updateStatus()
end

-- Teleport function
local function teleportToCamera()
    if not state.isFlying then return end
    
    local character = player.Character
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    
    if hrp and humanoid then
        -- Store current fly position for reference
        local targetPosition = state.flyPosition
        
        -- Stop flying first
        stopFlying()
        
        -- Teleport player
        humanoid:ChangeState(Enum.HumanoidStateType.Swimming) -- Prevent fall damage
        wait(0.1)
        hrp.CFrame = CFrame.new(targetPosition)
        humanoid:ChangeState(Enum.HumanoidStateType.Running)
        
        status.Text = "TELEPORTED TO CAMERA POSITION"
        wait(2)
        updateStatus()
    end
end

-- Viewing system
local function startViewing()
    if #state.markers == 0 then
        status.Text = "NO MARKERS PLACED"
        return
    end
    
    state.isViewing = true
    state.currentMarkerIndex = 1
    state.viewAngle = Vector2.new(0, 0)
    state.zoomLevel = 1
    
    -- Switch camera
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
    
    -- Show/hide UI
    viewControls.Visible = true
    exitBtn.Visible = true
    flyBtn.Visible = false
    markBtn.Visible = false
    viewBtn.Visible = false
    clearBtn.Visible = false
    
    updateStatus()
end

local function stopViewing()
    state.isViewing = false
    
    -- Return camera
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    
    -- Show/hide UI
    viewControls.Visible = false
    exitBtn.Visible = false
    flyBtn.Visible = true
    markBtn.Visible = true
    viewBtn.Visible = true
    clearBtn.Visible = true
    
    updateStatus()
end

local function switchMarker(direction)
    if #state.markers == 0 then return end
    
    if direction == "next" then
        state.currentMarkerIndex = state.currentMarkerIndex + 1
        if state.currentMarkerIndex > #state.markers then
            state.currentMarkerIndex = 1
        end
    elseif direction == "prev" then
        state.currentMarkerIndex = state.currentMarkerIndex - 1
        if state.currentMarkerIndex < 1 then
            state.currentMarkerIndex = #state.markers
        end
    end
    
    updateStatus()
end

-- Flying movement
local flyDirections = {
    forward = false,
    back = false,
    left = false,
    right = false,
    up = false,
    down = false
}

-- Camera rotation
local cameraRotations = {
    left = false,
    right = false,
    up = false,
    down = false
}

-- Button press events for movement
flyForward.MouseButton1Down:Connect(function()
    flyDirections.forward = true
end)
flyForward.MouseButton1Up:Connect(function()
    flyDirections.forward = false
end)

flyBack.MouseButton1Down:Connect(function()
    flyDirections.back = true
end)
flyBack.MouseButton1Up:Connect(function()
    flyDirections.back = false
end)

flyLeft.MouseButton1Down:Connect(function()
    flyDirections.left = true
end)
flyLeft.MouseButton1Up:Connect(function()
    flyDirections.left = false
end)

flyRight.MouseButton1Down:Connect(function()
    flyDirections.right = true
end)
flyRight.MouseButton1Up:Connect(function()
    flyDirections.right = false
end)

flyUp.MouseButton1Down:Connect(function()
    flyDirections.up = true
end)
flyUp.MouseButton1Up:Connect(function()
    flyDirections.up = false
end)

flyDown.MouseButton1Down:Connect(function()
    flyDirections.down = true
end)
flyDown.MouseButton1Up:Connect(function()
    flyDirections.down = false
end)

-- Button press events for camera rotation
lookLeft.MouseButton1Down:Connect(function()
    cameraRotations.left = true
end)
lookLeft.MouseButton1Up:Connect(function()
    cameraRotations.left = false
end)

lookRight.MouseButton1Down:Connect(function()
    cameraRotations.right = true
end)
lookRight.MouseButton1Up:Connect(function()
    cameraRotations.right = false
end)

lookUp.MouseButton1Down:Connect(function()
    cameraRotations.up = true
end)
lookUp.MouseButton1Up:Connect(function()
    cameraRotations.up = false
end)

lookDown.MouseButton1Down:Connect(function()
    cameraRotations.down = true
end)
lookDown.MouseButton1Up:Connect(function()
    cameraRotations.down = false
end)

-- Main button events
flyBtn.MouseButton1Click:Connect(startFlying)
markBtn.MouseButton1Click:Connect(placeMarker)
viewBtn.MouseButton1Click:Connect(startViewing)
clearBtn.MouseButton1Click:Connect(clearAllMarkers)
exitBtn.MouseButton1Click:Connect(function()
    if state.isFlying then
        stopFlying()
    elseif state.isViewing then
        stopViewing()
    end
end)

-- Teleport button event
teleportBtn.MouseButton1Click:Connect(teleportToCamera)

-- Viewing controls
viewPrev.MouseButton1Click:Connect(function()
    switchMarker("prev")
end)

viewNext.MouseButton1Click:Connect(function()
    switchMarker("next")
end)

viewUp.MouseButton1Click:Connect(function()
    state.viewAngle = Vector2.new(
        state.viewAngle.X,
        state.viewAngle.Y - 0.2
    )
end)

viewDown.MouseButton1Click:Connect(function()
    state.viewAngle = Vector2.new(
        state.viewAngle.X,
        state.viewAngle.Y + 0.2
    )
end)

-- Main game loop
local connection
connection = RunService.Heartbeat:Connect(function(delta)
    if state.isFlying then
        local camera = Workspace.CurrentCamera
        
        -- Update camera rotation based on buttons
        local rotationSpeed = 3 * delta
        if cameraRotations.left then
            state.flyAngle = Vector2.new(state.flyAngle.X - rotationSpeed, state.flyAngle.Y)
        end
        if cameraRotations.right then
            state.flyAngle = Vector2.new(state.flyAngle.X + rotationSpeed, state.flyAngle.Y)
        end
        if cameraRotations.up then
            state.flyAngle = Vector2.new(state.flyAngle.X, math.min(state.flyAngle.Y + rotationSpeed, math.pi/2 - 0.1))
        end
        if cameraRotations.down then
            state.flyAngle = Vector2.new(state.flyAngle.X, math.max(state.flyAngle.Y - rotationSpeed, -math.pi/2 + 0.1))
        end
        
        -- Calculate forward/right vectors based on yaw
        local yaw = state.flyAngle.X
        local forward = Vector3.new(-math.sin(yaw), 0, -math.cos(yaw))
        local right = Vector3.new(math.cos(yaw), 0, -math.sin(yaw))
        
        -- Calculate movement
        local move = Vector3.new(0, 0, 0)
        
        if flyDirections.forward then
            move = move + forward
        end
        if flyDirections.back then
            move = move - forward
        end
        if flyDirections.right then
            move = move + right
        end
        if flyDirections.left then
            move = move - right
        end
        if flyDirections.up then
            move = move + Vector3.new(0, 1, 0)
        end
        if flyDirections.down then
            move = move - Vector3.new(0, 1, 0)
        end
        
        -- Apply movement
        if move.Magnitude > 0 then
            move = move.Unit * config.flySpeed * delta
            state.flyPosition = state.flyPosition + move
        end
        
        -- Create camera CFrame from angles
        local pitch = state.flyAngle.Y
        local lookVector = Vector3.new(
            -math.sin(yaw) * math.cos(pitch),
            math.sin(pitch),
            -math.cos(yaw) * math.cos(pitch)
        )
        
        -- Update camera
        camera.CFrame = CFrame.new(state.flyPosition, state.flyPosition + lookVector)
        camera.FieldOfView = config.cameraFOV
        
    elseif state.isViewing and #state.markers > 0 then
        local camera = Workspace.CurrentCamera
        local markData = state.markers[state.currentMarkerIndex]
        
        if markData then
            -- Calculate camera position based on angle and zoom
            local basePos = markData.position
            local yaw = state.viewAngle.X
            local pitch = state.viewAngle.Y
            local distance = 10 * state.zoomLevel
            
            -- Calculate offset
            local offset = Vector3.new(
                math.sin(yaw) * math.cos(pitch) * distance,
                math.sin(pitch) * distance,
                math.cos(yaw) * math.cos(pitch) * distance
            )
            
            local cameraPos = basePos + offset
            
            -- Set camera to look at marker
            camera.CFrame = CFrame.new(cameraPos, basePos)
            camera.FieldOfView = config.cameraFOV / state.zoomLevel
        end
    end
end)

-- Mobile touch for rotation in viewing mode
local touchStart = nil
local originalAngle = nil

UserInputService.TouchStarted:Connect(function(touch)
    if not state.isViewing then return end
    
    touchStart = touch.Position
    originalAngle = state.viewAngle
end)

UserInputService.InputChanged:Connect(function(input)
    if not state.isViewing or not touchStart or input.UserInputType ~= Enum.UserInputType.Touch then
        return
    end
    
    local delta = input.Position - touchStart
    local sensitivity = 0.01
    
    state.viewAngle = Vector2.new(
        originalAngle.X - delta.X * sensitivity,
        originalAngle.Y - delta.Y * sensitivity
    )
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        touchStart = nil
        originalAngle = nil
    end
end)

-- Cleanup
gui.Destroying:Connect(function()
    if connection then
        connection:Disconnect()
    end
    clearAllMarkers()
end)

updateStatus()

print("Mobile Fly & Mark System loaded")
print("FREE CAMERA - Fly with camera (360° rotation)")
print("PLACE MARK - Save position as marker")
print("VIEW MARKS - View saved markers with camera control")
print("TELEPORT - Teleport to camera position")
